const courseId = 'c0000000-0000-0000-0001-000000000003';

const lessonsPart2 = [
  {
    id: '10000000-0001-0003-0000-000000000005',
    course_id: courseId,
    title: 'label და accessibility',
    slug: 'html-label-accessibility',
    content_type: 'practice',
    language: 'html',
    xp_reward: 25,
    sort_order: 5,
    estimated_minutes: 20,
    content: `
# \`<label>\` ტეგი და ფორმის ხელმისაწვდომობა

## თეორია

ოდესმე შეგიმჩნევიათ, რომ ზოგ საიტზე პატარა მოსანიშნ უჯრაზე (Checkbox) დაჭერა ძალიან რთულია და ტელეფონში განსაკუთრებით გიჭირთ მისი მორტყმა? ხოლო კარგად აწყობილ საიტებზე, თვითონ წარწერაზე (ტექსტზე) დაჭერაც კი უჯრას მონიშნულს ხდის. საიდუმლო პატარა, მაგრამ უაღრესად მნიშვნელოვან ტეგში — \`<label>\`-ში იმალება. 

როგორც წესი, \`<input>\` ველებს (იქნება ეს ტექსტური თუ მოსანიშნი) გვერდით ვუწერთ რაიმე ტექსტს (Label), რათა მომხმარებელმა გაიგოს, რას ვითხოვთ მისგან. თუ ამას პირდაპირ \`<div>\`-ში დავწერთ, ვიზუალურად ყველაფერი წესრიგში იქნება, თუმცა ბრაუზერისთვის და მით უმეტეს ეკრანის წამკითხველებისთვის (რომლებსაც უსინათლოები იყენებენ), დაუწერელი ტექსტი და ველი ერთმანეთთან კავშირში არაა. 

\`<label>\` ტეგი არის ამ კავშირის შექმნის ოფიციალური სტანდარტი. ის ანიჭებს სათაურს კონკრეტულ \`<input>\`-ს. 

ეს კავშირი მყარდება \`for\` ატრიბუტის საშუალებით. \`<label>\` იღებს \`for\` ატრიბუტს (მაგ: \`<label for="username">\`), ხოლო დასაკავშირებელი \`<input>\` იღებს იდენტურ \`id\` ატრიბუტს (მაგ: \`<input id="username">\`). შედეგად:
1. იზრდება ხელმისაწვდომობა (Accessibility), რადგან ეკრანის წამკითხველი გაიგებს, რა დანიშნულება აქვს ველს.
2. იზრდება გამოყენებადობა (Usability) — \`label\`-ზე დაწკაპუნებით ბრაუზერი ავტომატურად გადაიტანს ფოკუსს დაკავშირებულ ველზე, ან მონიშნავს Checkbox/Radio ღილაკს, რაც განსაკუთრებით ზრდის მომხმარებლის კომფორტს სენსორულ ეკრანებზე.

*ასევე შესაძლებელია \`input\` ტეგის უშუალოდ \`label\` ტეგის შიგნით ჩასმა. ამ შემთხვევაში \`for\` და \`id\` დაკავშირება აღარ არის სავალდებულო, ლოგიკა ავტომატურად ამუშავდება.*

## კოდის მაგალითი
\`\`\`html
<form>
  <!-- კატეგორიულად დასაგმობი პრაქტიკა ❌ -->
  <span>სახელი:</span>
  <input type="text" name="firstName">
  <br>

  <!-- სწორი და რეკომენდებული პრაქტიკა ✅ -->
  <label for="lastName">გვარი:</label>
  <input type="text" id="lastName" name="lastName">
  
  <br><br>
  
  <!-- Checkbox-ის მაგალითი! ამ ტექსტზე დაჭერითაც მოინიშნება ✅ -->
  <input type="checkbox" id="subscribe" name="subscribe">
  <label for="subscribe">გამომიგზავნეთ სიახლეები</label>
</form>
\`\`\`

## ხშირად დაშვებული შეცდომები
- \`for\` ატრიბუტს და \`id\` ატრიბუტს შორის სახელების უმნიშვნელო აცდენაც კი (დიდი ან პატარა ასოებით) კავშირს გაწყვეტს. 
- \`<label>\` -ის ნაცვლად \`<p>\` ან \`<span>\` ტეგების გამოყენება ფორმების ასაწყობად.

## ქვიზი
1. რა არის \`<label>\` ტეგის მთავარი დანიშნულება?
- [x] დაუკავშირდეს კონკრეტულ \`<input>\`-ს ტექსტური აღწერილობით და გაზარდოს ხელმისაწვდომობა (Accessibility).
- [ ] ტექსტის გასქელება / დიზაინში გამოყოფა.
- [ ] ფორმის მონაცემების გადამოწმება (Validation).

2. რომელი ატრიბუტები გამოიყენება \`<label>\` და \`<input>\` ტეგების ერთმანეთთან დასაკავშირებლად?
- [ ] label="link" და input="link"
- [x] label-ის \`for\` ატრიბუტი და input-ის \`id\` ატრიბუტი.
- [ ] label-ის \`id\` და input-ის \`class\`.

3. რა ხდება, როცა ჩექბოქსზე (\`checkbox\`) მიბმულ \`label\`-ის ტექსტზე აწკაპუნებთ?
- [ ] ეკრანზე ჩნდება საიტი.
- [ ] არაფერი.
- [x] ბრაუზერი ავტომატურად მონიშნავს ან გამორთავს ჩექბოქსს.
    `,
    starter_code: `<form>
  <!-- დაუკავშირეთ მოცემული ტეგები მითითებული for და id ატრიბუტებით -->
  <label>თქვენი ელ-ფოსტა:</label>
  <input type="email">
</form>`,
    solution_code: `<form>
  <label for="userEmail">თქვენი ელ-ფოსტა:</label>
  <input type="email" id="userEmail">
</form>`,
    challenge_text: `მოცემულ კოდში დაუკავშირეთ ერთმანეთს <strong>label</strong> და <strong>input</strong> ტეგები. <strong>label</strong>-ს დაუმატეთ ატრიბუტი <strong>for="userEmail"</strong>, ხოლო <strong>input</strong>-ს დაუმატეთ <strong>id="userEmail"</strong>.`,
    test_cases: JSON.stringify([
      { testName: 'label-ს უნდა ჰქონდეს for="userEmail"', testCode: 'expect(document.querySelector("label").getAttribute("for")).toBe("userEmail");' },
      { testName: 'input-ს უნდა ჰქონდეს id="userEmail"', testCode: 'expect(document.querySelector("input").getAttribute("id")).toBe("userEmail");' }
    ])
  },
  {
    id: '10000000-0001-0003-0000-000000000006',
    course_id: courseId,
    title: 'validation ატრიბუტები — required, minlength, pattern',
    slug: 'html-validation-attributes',
    content_type: 'practice',
    language: 'html',
    xp_reward: 35,
    sort_order: 6,
    estimated_minutes: 25,
    content: `
# HTML5 ვალიდაციის (შემოწმების) ატრიბუტები

## თეორია

თუ მომხმარებელს რეგისტრაციის ფორმიდან არ მოვთხოვთ სახელს და ისე გავაგზავნინებთ ცარიელ ფორმას სერვერზე, ჩვენს მონაცემთა ბაზაში სიცარიელე გაჩნდება. იმისათვის, რომ სერვერი დავიცვათ და კლიენტსაც ვუთხრათ, სად დაუშვა შეცდომა (Client-side Validation), HTML5 გვთავაზობს ჩაშენებულ ატრიბუტებს.

ამ ატრიბუტების მეშვეობით ბრაუზერი ავტომატურად ამოწმებს ველებს \`<button type="submit">\`-ზე დაჭერისას და თუ მოთხოვნები არ კმაყოფილდება, ფორმას არ აგზავნის და მომხმარებელს ეკრანზე უგდებს გაფრთხილებას. 

ყველაზე მნიშვნელოვანი ვალიდაციის ატრიბუტები:
1. **\`required\`**: ელემენტარული, მაგრამ უძლიერესი ატრიბუტი. თუ მიანიჭებთ \`<input>\`-ს \`required\` ატრიბუტს (მნიშვნელობის გარეშე), მომხმარებელი ფიზიკურად ვერ გააგზავნის ფორმას, სანამ ამ ველს არ შეავსებს.
2. **\`minlength\` / \`maxlength\`**: ამ ატრიბუტებით განვსაზღვრავთ, რამდენი სიმბოლოა დასაშვები მინიმუმ და მაქსიმუმ. მაგალითად პაროლისთვის \`minlength="8"\` ავალდებულებს მომხმარებელს ჩაწეროს სულ მცირე 8 სიმბოლო.
3. **\`min\` / \`max\`**: ოდნავ განსხვავდება წინა ორისგან. \`length\` ნიშნავს სიგრძეს სტრიქონში, თუმცა \`min\` და \`max\` გამოიყენება რიცხვებისთვის (\`type="number"\`) და თარიღებისთვის. მაგ: \`min="1"\` ნიშნავს რომ 0-ს ან უარყოფით ციფრს ვერ ჩაწერს.
4. **\`pattern\`**: ეს არის ყველაზე რთული და მძლავრი ინსტრუმენტი, რომელიც ეფუძნება ე.წ. Regular Expressions (RegEx). შეგიძლიათ დააწესოთ ფორმატი, რომელსაც უნდა აკმაყოფილებდეს ტექსტი. 

ბრაუზერის ჩაშენებული ვალიდაცია არაჩვეულებრივია, თუმცა ბოროტმოქმედებს მარტივად შეუძლიათ მისი გვერდის ავლა Developer Tools-ით, ამიტომ უსაფრთხოებისთვის მეორე-დონის შემოწმება ყოველთვის ხდება სერვერულ ნაწილში (Backend-ში).

## კოდის მაგალითი
\`\`\`html
<form action="/register">
  <!-- სავალდებულო (required) ველი -->
  <label for="username">სახელი:</label>
  <input type="text" id="username" required>
  
  <!-- პაროლი მინიმუმ 8 სიმბოლო -->
  <label for="password">პაროლი:</label>
  <input type="password" id="password" minlength="8" required>
  
  <!-- ასაკი მინიმუმ 18 -->
  <label for="age">ასაკი (მხოლოდ სრულწლოვანთათვის):</label>
  <input type="number" id="age" min="18" max="100">

  <!-- პატერნი ამოწმებს, რომ შეყვანილი იქნას მხოლოდ 3 ლათინური დიდი ასო -->
  <label for="country_code">ქვეყნის 3 აღმნიშვნელი ასო:</label>
  <input type="text" id="country_code" pattern="[A-Z]{3}">
  
  <button type="submit">რეგისტრაცია</button>
</form>
\`\`\`

## ხშირად დაშვებული შეცდომები
- \`required\` ატრიბუტზე \`"true"\`-ს ან სხვა მნიშვნელობის მინიჭება. ინტუიციურია, მაგრამ ტექნიკურად საკმარისია უბრალოდ სიტყვა \`required\`-ის დაწერა (მას ბულეანის ატრიბუტი ჰქვია). 
- ვალიდაციების დამატება ველებზე, მაგრამ ფორმის გარეთ მოთავსებული ღილაკით (რომელიც ჯავასკრიპტითაა დაკავშირებული ფორმასთან). თუ ფორას არეგულირებთ JS-ით \`e.preventDefault()\` მეშვეობით, HTML ვალიდაციის pop-over-ები გაითიშება.

## ქვიზი
1. რას აკეთებს ატრიბუტი \`required\`?
- [x] უზრუნველყოფს, რომ ფორმა არ გაიგზავნოს, თუ ის ველი ცარიელია.
- [ ] აუცილებლად მოითხოვს, რომ ველში მოთავსებული ტექსტი დაემთხვეს უკვე მითითებულ პაროლს.
- [ ] დიზაინში ველს წითლად აფერადებს.

2. რომელი ატრიბუტი დაგვეხმარება პაროლი გავხადოთ მინიმუმ 8 სიმბოლოს სიგრძის მქონე?
- [ ] min="8"
- [x] minlength="8"
- [ ] length="8"

3. რა არის HTML Client-side ვალიდაციის შეზღუდვა?
- [x] მომხმარებელს შეუძლია DevTools-ით წაშალოს ატრიბუტი და გვერდი აუაროს შემოწმებას, ამიტომ სერვერზე ვალიდაციაც აუცილებელია.
- [ ] ის ამძიმებს საიტს და არ არის სწრაფი.
- [ ] მას არ აქვს შეზღუდვა და 100%-ით საიმედოა.
    `,
    starter_code: `<form>
  <label for="pass">პაროლი</label>
  <input type="password" id="pass">
</form>`,
    solution_code: `<form>
  <label for="pass">პაროლი</label>
  <input type="password" id="pass" required minlength="6">
</form>`,
    challenge_text: `მოცემულ პაროლის <strong>input</strong>-ს დაუმატეთ <strong>required</strong> ატრიბუტი და <strong>minlength="6"</strong> ატრიბუტი, რათა მომხმარებელმა ცარიელი ველი არ გამოგზავნოს და დაწეროს მინიმუმ 6 სიმბოლო.`,
    test_cases: JSON.stringify([
      { testName: 'input-ს უნდა ჰქონდეს required ატრიბუტი', testCode: 'expect(document.querySelector("input").hasAttribute("required")).toBeTruthy();' },
      { testName: 'input-ს უნდა ჰქონდეს minlength=6', testCode: 'expect(document.querySelector("input").getAttribute("minlength")).toBe("6");' }
    ])
  },
  {
    id: '10000000-0001-0003-0000-000000000007',
    course_id: courseId,
    title: 'fieldset და legend',
    slug: 'html-fieldset-legend',
    content_type: 'practice',
    language: 'html',
    xp_reward: 20,
    sort_order: 7,
    estimated_minutes: 10,
    content: `
# \`<fieldset>\` და \`<legend>\`

## თეორია

წარმოიდგინეთ ბანკის ანალიტიკური რეგისტრაციის ფორმა, რომელიც ითხოვს უზარმაზარ ინფორმაციას: პერსონალური მონაცემები, საკონტაქტო ინფო, ტრანზაქციის ისტორია, და სხვა. ამდენი შეყრილი ველი აღქმისთვის მძიმე და დამღლელია.

HTML გთავაზობს ფორმის ლოგიკურად დაჯგუფების (და ვიზუალურად გალამაზების) შესანიშნავ საშუალებას \`<fieldset>\` კონტეინერის სახით.
- \`<fieldset>\` ტეგი თავსდება \`<form>\`-ის შიგნით. ის აჯამებს / ალაგებს მსგავს \`<input>\` ველებს ერთ მთლიანობაში გაერთიანებით. ბრაუზერი ავტომატურად შემოავლებს მას სუსტ ჩარჩოს (Border-ს). 
- \`<legend>\` გამოიყენება \`<fieldset>\` კონტეინერის დასასათაურებლად. ის უნდა ჩაიწეროს უშუალოდ \`<fieldset>\` ტეგის გახსნისთანავე. ბრაუზერი მას ჩარჩოს ზედა ხაზზე, შუაში "ჩაჭრის" და ლამაზად გამოაჩენს.

როგორც უკვე აღვნიშნეთ, Screen Reader-ების შემთხვევაში, როდესაც ისინი შევლენ ახალ \`<fieldset>\`-ში, მყისიერად გააჟღერებენ \`<legend>\`-ის ტექსტს მიმდევრობით ველებისთვის.

## კოდის მაგალითი
\`\`\`html
<form action="/checkout">
  <!-- პერსონალური ინფოს დაჯგუფება -->
  <fieldset>
    <legend>პირადი ინფორმაცია</legend>
    <label for="fname">სახელი:</label>
    <input type="text" id="fname" name="fname"><br><br>
    
    <label for="lname">გვარი:</label>
    <input type="text" id="lname" name="lname">
  </fieldset>
  
  <!-- საკრედიტო ბარათის დაჯგუფება -->
  <fieldset>
    <legend>გადახდის დეტალები</legend>
    <label for="card">ბარათის ნომერი:</label>
    <input type="text" id="card" name="card">
  </fieldset>
  
  <button type="submit">ყიდვა</button>
</form>
\`\`\`

## ხშირად დაშვებული შეცდომები
- \`<legend>\` ტეგის \`<fieldset>\`-ის გარეთ დაწერა, რაც დაარღვევს ვიზუალურ განლაგებას ჩარჩოზე.
- \`<fieldset>\` კონტეინერის ბოროტად გამოყენება პატარა ფორმებზე, რომლებსაც ისედაც მხოლოდ 2 ველი აქვთ. 

## ქვიზი
1. რას აკეთებს <fieldset> ტეგი?
- [x] ალაგებს და აჯგუფებს მსგავს ველებს (input-ებს) და უშენებს მათ ვიზუალურ ჩარჩოს ფორმის შიგნით.
- [ ] ასუფთავებს ფორმას.
- [ ] აგზავნის მონაცემებს.

2. რომელი ტეგი გამოიყენება <fieldset> ჯგუფის დასასათაურებლად, რომელიც ჩარჩოზე მაგრდება?
- [ ] <title>
- [x] <legend>
- [ ] <caption>

3. რა იქნება, თუ უგულებელვყოფთ legend ტეგს fieldset-ის შიგნით?
- [x] Fieldset უბრალოდ ჩარჩოს მიაწერს ველებს, მაგრამ სათაურის გარეშე, რაც Screen Reader-სთვის დააბნეველი იქნება და კარგავს მის მთავარ სემანტიკურ არსს.
- [ ] ფორმა არ გაიგზავნება.
- [ ] ეკრანზე გამოიტანს შეცდომას.
    `,
    starter_code: `<form>
  <!-- შემოავლეთ fieldset -->
  <legend>სწავლის მიმართულება</legend>
  <label for="subject">საგანი:</label>
  <input type="text" id="subject">
</form>`,
    solution_code: `<form>
  <fieldset>
    <legend>სწავლის მიმართულება</legend>
    <label for="subject">საგანი:</label>
    <input type="text" id="subject">
  </fieldset>
</form>`,
    challenge_text: `მოცემულ ფორმაში უკვე გვაქვს <strong>legend</strong>, <strong>label</strong> და <strong>input</strong>. თქვენი მიზანია ამ სამივე ტეგს გარშემო (გარედან) შემოავლოთ <strong>fieldset</strong> (გამხსნელი და დამხურავი) ტეგი.`,
    test_cases: JSON.stringify([
      { testName: 'fieldset უნდა არსებობდეს', testCode: 'expect(document.querySelector("fieldset")).toBeTruthy();' },
      { testName: 'legend უნდა იყოს fieldset-ის შიგნით', testCode: 'expect(document.querySelector("fieldset > legend")).toBeTruthy();' }
    ])
  }
];

module.exports = lessonsPart2;
