const courseId = 'c0000000-0000-0000-0001-000000000003';

const lessonsPart1 = [
  {
    id: '10000000-0001-0003-0000-000000000001',
    course_id: courseId,
    title: 'form ელემენტი — action, method',
    slug: 'html-forms-action-method',
    content_type: 'practice',
    language: 'html',
    xp_reward: 20,
    sort_order: 1,
    estimated_minutes: 15,
    content: `
# HTML ფორმები: \`<form>\` ტეგი

## თეორია

ინტერნეტი არ არის მხოლოდ ცალმხრივი მოსაკითხი წიგნი. თანამედროვე ვებსაიტები ინტერაქტიულია და მომხმარებელს აძლევს საშუალებას, ინფორმაცია სერვერზე გაგზავნოს (მაგალითად: დარეგისტრირდეს, დატოვოს კომენტარი, მოიძიოს რამე ან იყიდოს პროდუქტი). ასეთი მონაცემების შეგროვება ვებ-გვერდზე ხდება ფორმების (Forms) მეშვეობით.

HTML-ში ფორმის შესაქმნელად გამოიყენება \`<form>\` ტეგი. ის არის კონტეინერი, რომელიც თავის თავში მოიცავს სპეციალურ ველებს (ტექსტის შესაყვანად, მოსანიშნად, გასაგზავნ ღილაკს და ასე შემდეგ). უბრალოდ \`<form>\` ტეგის დაწერა საკმარისი არ არის, სერვერმა რომ გაიგოს სად და როგორ მიიღოს მონაცემები, მას სჭირდება ორი მთავარი ატრიბუტი:

1. **\`action\`**: ეს ატრიბუტი მიუთითებს სერვერის კონკრეტულ მისამართს (URL), სადაც ეს ინფორმაცია უნდა გაიგზავნოს დამუშავებისთვის (მაგალითად: \`action="/api/register"\`). 
2. **\`method\`**: ეს ატრიბუტი განსაზღვრავს HTTP მეთოდს — ინფორმაციის გაგზავნის გზას. ყველაზე ხშირად ვიყენებთ ორ მეთოდს:
   - \`GET\`: გამოიყენება ძირითადად ინფორმაციის მოსაძიებლად (მაგალითად Google Search-ში). ამ დროს, ველებში ჩაწერილი მონაცემები ღიად, ლინკის (URL) ბოლოში ემატება. ამიტომ \`GET\` კატეგორიულად იკრძალება პაროლების და პირადი მონაცემების გასაგზავნად!
   - \`POST\`: გამოიყენება სერვერზე ინფორმაციის გასაგზავნად ან დასამატებლად (მაგალითად რეგისტრაციისას, სურათის ატვირთვისას). მონაცემები ლინკში არ ჩანს და ის მოთავსებულია HTTP "სხეულში" (Body), რაც ბევრად დაცულია პირადობის ქურდობისგან.

არ დაგავიწყდეთ, რომ \`<form>\` მხოლოდ კონტეინერია, იგი ვიზუალურად არაფერს გამოიტანს ეკრანზე, სანამ მის შიგნით შესაყვან ველებს (\`<input>\`) არ მოათავსებთ.

## კოდის მაგალითი
\`\`\`html
<!-- საძიებო ფორმა: იყენებს GET მეთოდს, რადგან არ არის გასაიდუმლოებული -->
<form action="/search" method="GET">
  <!-- აქ იქნება საძიებო ველები -->
</form>

<hr>

<!-- რეგისტრაციის ფორმა: აუცილებლად იყენებს POST მეთოდს -->
<form action="/registerUser" method="POST">
  <!-- აქ მოთავსდება მომხმარებლის სახელი და პაროლის ველები -->
</form>
\`\`\`

## ხშირად დაშვებული შეცდომები
- პაროლის შემცველი ფორმის შექმნა \`method="GET"\`-ით. ასეთ შემთხვევაში პაროლი პირდაპირ გამოჩნდება საიტის ლინკში \`?password=ჩემიპაროლი\`! ფორმატით, რაც კრიტიკული შეცდომაა.
- \`action\` ატრიბუტის გამოტოვება, რის გამოც ბრაუზერმა არ იცის, ვის მიმართოს გაგზავნის ღილაკზე დაჭერისას და უბრალოდ იმავე გვერდს არეფრეშებს.

## ქვიზი
1. რისთვის გამოიყენება <form> ტეგი?
- [x] მომხმარებლის მიერ შეყვანილი მონაცემების შესაგროვებლად და სერვერზე გასაგზავნად.
- [ ] ტექსტის ლამაზად დასაფორმატებლად.
- [ ] მხოლოდ საძიებო ველისთვის (Search).

2. რას განსაზღვრავს \`action\` ატრიბუტი ფორმაში?
- [ ] რომელ ენაზე იგზავნება ინფორმაცია.
- [x] იმ URL მისამართს, სადაც მონაცემები იგზავნება შესამუშავებლად.
- [ ] ფორმის ანიმაციას.

3. რომელი მეთოდი უნდა გამოვიყენოთ საიდუმლო ინფორმაციის (მაგ: პაროლის) გასაგზავნად?
- [ ] GET 
- [x] POST
- [ ] PUT
    `,
    starter_code: `<!-- დაწერეთ თქვენი <form> ტეგი ქვემოთ -->
`,
    solution_code: `<form action="/login" method="POST">
</form>`,
    challenge_text: `შექმენით ცარიელი <strong>form</strong> ტეგი. მიანიჭეთ მას ორი ატრიბუტი: <strong>action</strong> მნიშვნელობით <strong>"/login"</strong> და <strong>method</strong> მნიშვნელობით <strong>"POST"</strong>. ეს სრულად მოამზადებს კონტეინერს შესვლის (ალიზაციის) დაცული ფორმისთვის.`,
    test_cases: JSON.stringify([
      { testName: 'უნდა არსებობდეს form ტეგი', testCode: 'expect(document.querySelector("form")).toBeTruthy();' },
      { testName: 'action უნდა იყოს /login', testCode: 'expect(document.querySelector("form").getAttribute("action")).toBe("/login");' },
      { testName: 'method უნდა იყოს POST (დიდი ან პატარა ასოებით)', testCode: 'expect(document.querySelector("form").getAttribute("method").toUpperCase()).toBe("POST");' }
    ])
  },
  {
    id: '10000000-0001-0003-0000-000000000002',
    course_id: courseId,
    title: 'input ტიპები — text, email, password, number, date, checkbox, radio',
    slug: 'html-input-types',
    content_type: 'practice',
    language: 'html',
    xp_reward: 35,
    sort_order: 2,
    estimated_minutes: 25,
    content: `
# ფორმის ველები: \`<input>\` ტეგი

## თეორია

ფორმის გული და სული არის \`<input>\` (შეყვანა) ტეგი. ისიც "ცარიელ" (Void) ტეგების ოჯახს მიეკუთვნება და დამხურავი ტეგი არ გააჩნია. სწორედ აქ წერს მომხმარებელი ინფორმაციას. HTML5-მა მნიშვნელოვნად გააფართოვა მისი შესაძლებლობები \`type\` ატრიბუტის მეშვეობით. ერთი უბრალო \`<input>\` ტეგი, \`type\` ატრიბუტის შეცვლით, შეიძლება გახდეს სატექსტო ველი, პაროლის ველი, კალენდარი თუ მოსანიშნი უჯრა.

ყველაზე გავრცელებული Input ტიპებია:
- \`type="text"\`: სტანდარტული, ერთხაზიანი სატექსტო ველი (მაგ. სახელის შესაყვანად).
- \`type="password"\`: სატექსტო ველი, სადაც აკრეფილი სიმბოლოები იფარება წერტილებით ან ვარსკვლავებით.
- \`type="email"\`: ბრაუზერი ამოწმებს, შეიყვანეს თუ არა ტექსტში @ სიმბოლო და გაგზავნისას აფრთხილებს მომხმარებელს, თუ ეს არარეალური ელ-ფოსტაა.
- \`type="number"\`: ზღუდავს ველს მხოლოდ ციფრების შესაყვანად. ასევე უჩნდება პატარა ისრები რიცხვის გასაზრდელად ან შესამცირებლად.
- \`type="date"\`: ავტომატურად ხსნის ჩაშენებულ კალენდარს, საიდანაც მომხმარებელი ირჩევს თარიღს.
- \`type="checkbox"\`: კვადრატული მოსანიშნი (Tick) უჯრა. მისი გამოყენება ხდება მაშინ, როდესაც მომხმარებელს მრავალი ვარიანტიდან რამდენიმეს მონიშვნა შეუძლია.
- \`type="radio"\`: წრიული მოსანიშნი. გამოიყენება ისეთ სიტუაციებში, როცა მრავალი ვარიანტიდან მომხმარებელმა გადაჭრით მხოლოდ ერთი უნდა აირჩიოს (მაგალითად, სქესის არჩევისას: მდედრობითი, მამრობითი). ამისთვის აუცილებელია ყველა "რადიო" ღილაკს ერთნაირი \`name\` ატრიბუტი ჰქონდეს, რათა ბრაუზერმა ისინი ერთ დაჯგუფებად აღიქვას და ერთის მონიშვნისას მეორეს მონიშვნა წაართვას.

ამავდროულად ძალიან სასარგებლოა \`placeholder\` ატრიბუტი, რომელიც ველში გამჭვირვალე ტექსტს (მინიშნებას) წერს, სანამ მომხმარებელი წერას დაიწყებდეს.

## კოდის მაგალითი
\`\`\`html
<form action="/submit">
  <!-- ტექსტი და მინიშნება placeholder-ით -->
  <input type="text" placeholder="თქვენი სახელი">
  
  <input type="email" placeholder="ელ-ფოსტა">
  <input type="password" placeholder="ახალი პაროლი">
  
  <!-- თარიღის არჩევა -->
  <input type="date">
  
  <!-- Checkbox-ების გამოყენება (შეგვიძლია მოვნიშნოთ ორივე) -->
  ვეთანხმები წესებს: <input type="checkbox" name="terms">
  მინდა სიახლეების მიღება: <input type="checkbox" name="newsletter">
  
  <!-- Radio-ს გამოყენება (მხოლოდ ერთს აირჩევს, რადგან name ორივეს "gender" აქვს) -->
  ქალი: <input type="radio" name="gender" value="female">
  კაცი: <input type="radio" name="gender" value="male">
</form>
\`\`\`

## ხშირად დაშვებული შეცდომები
- პაროლის ველისთვის \`type="text"\` მითითება. ამ დროს ზურგსუკან მდგომმა შეიძლება დაინახოს თქვენი პაროლი. 
- Radio ღილაკებისთვის განსხვავებული \`name\` ატრიბუტების მინიჭება. ამ დროს იკარგება Radio-ს მთავარი ფუნქცია — მომხმარებელი ორივეს მონიშვნას შეძლებს, რაც ლოგიკურად არასწორია.

## ქვიზი
1. რომელი ატრიბუტი აქცევს ჩვეულებრივ \`<input>\`-ს პაროლის მალულ ველად?
- [x] type="password"
- [ ] show="false"
- [ ] hide="text"

2. რას აკეთებს \`placeholder\` ატრიბუტი?
- [ ] ამოწმებს პაროლის სიძლიერეს.
- [x] აჩვენებს გამჭვირვალე მიმანიშნებელ ტექსტს ველის შიგნით, სანამ მომხმარებელი წერას დაიწყებს.
- [ ] ველის ადგილს იკავებს გვერდზე დასატევად.

3. რა არის განსხვავება \`checkbox\`-სა და \`radio\` ღილაკებს შორის?
- [ ] Checkbox მრგვალია, Radio კვადრატულია.
- [x] ჯგუფიდან Checkbox-ით შეგვიძლია მოვნიშნოთ რამდენიმე (ან ყველა), ხოლო Radio-თი მხოლოდ ერთი.
- [ ] არავითარი განსხვავება არ არის.
    `,
    starter_code: `<form>
  <!-- პირველი input: ტექსტური ველი placeholder-ით "თქვენი სახელი" -->
  

  <!-- მეორე input: პაროლის ველი placeholder-ით "პაროლი" -->
  
</form>`,
    solution_code: `<form>
  <input type="text" placeholder="თქვენი სახელი">
  <input type="password" placeholder="პაროლი">
</form>`,
    challenge_text: `ფორმის შიგნით დაწერეთ ორი <strong>input</strong>. პირველს მიანიჭეთ <strong>type="text"</strong> და <strong>placeholder="თქვენი სახელი"</strong>. მეორეს მიანიჭეთ <strong>type="password"</strong> და <strong>placeholder="პაროლი"</strong>. (საჭირო არაა label-ები თვალსაჩინოებისთვის)`,
    test_cases: JSON.stringify([
      { testName: 'უნდა იყოს text დასახელების ველი შესაბამისი placeholder-ით', testCode: 'expect(document.querySelector("input[type=\\"text\\"]").getAttribute("placeholder")).toBe("თქვენი სახელი");' },
      { testName: 'უნდა იყოს პაროლის ველი შესაბამისი placeholder-ით', testCode: 'expect(document.querySelector("input[type=\\"password\\"]").getAttribute("placeholder")).toBe("პაროლი");' }
    ])
  },
  {
    id: '10000000-0001-0003-0000-000000000003',
    course_id: courseId,
    title: 'textarea, select, option',
    slug: 'html-textarea-select',
    content_type: 'practice',
    language: 'html',
    xp_reward: 20,
    sort_order: 3,
    estimated_minutes: 15,
    content: `
# ვრცელი ტექსტი და ჩამოსაშლელი სიები

## თეორია

მიუხედავად იმისა, რომ \`<input>\` უამრავ საჭიროებას ფარავს, ის შეზღუდულია: მას მხოლოდ ერთი ხაზის (Line) დაწერა შეუძლია ან მხოლოდ რამოდენიმე ღილაკს გვთავაზობს. რეალურ სამყაროში ჩვენ ხშირად გვჭირდება კომენტარების ვრცელი ველი ან 50 ქვეყნიანი ჩამოსაშლელი სია, რისთვისაც ცალ-ცალკე 50 რადიო-ღილაკის დახატვა წარმოუდგენელია. 

ამისთვის HTML-ში ორი განსაკუთრებული ტეგი გვაქვს:

1. **\`<textarea>\` (ტექსტის არე):** გამოიყენება მრავალხაზიანი ტექსტების შესაყვანად (მაგალითად ბლოგის პოსტის წერისას, ან კომენტარის დატოვებისას). \`<input>\`-ისგან განსხვავებით, ეს ტეგი არ არის "ცარიელი" და მას აუცილებლად სჭირდება დამხურავი \`</textarea>\`. თუ მის შიგნით ტექსტს დაწერთ, ის ველის საწყისი (default) მნიშვნელობა იქნება. მნიშვნელოვანია: ამ ველის ზომის გაკონტროლება შესაძლებელია \`rows\` და \`cols\` ატრიბუტებით, რითაც ვეუბნებით რამდენ ხაზს და სიმბოლოს უნდა იტევდეს ის ეკრანზე.
2. **\`<select>\` და \`<option>\` (ჩამოსაშლელი სია - Dropdown):** როდესაც მომხმარებელმა მრავალი (10-ზე მეტი) ვარიანტიდან მხოლოდ ერთი უნდა აირჩიოს, სივრცის დასაზოგად ვიყენებთ \`<select>\` ტეგს. ეს ტეგი წარმოადგენს თავად ჩამოსაშლელ "ყუთს". თითოეული ასარჩევი ელემენტი მის შიგნით იწერება \`<option>\` (ვარიანტი) ტეგით. სერვერს ეგზავნება არჩეული \`<option>\`-ის \`value\` ატრიბუტში მოთავსებული მნიშვნელობა.

## კოდის მაგალითი
\`\`\`html
<form>
  <!-- ვრცელი კომენტარის ველი -->
  დატოვეთ კომენტარი: <br>
  <textarea name="message" rows="4" cols="50" placeholder="დაწერეთ აქ..."></textarea>
  
  <br><br>

  <!-- ჩამოსაშლელი მენიუ -->
  აირჩიეთ ქვეყანა:
  <select name="country">
    <option value="georgia">საქართველო</option>
    <option value="uk">დიდი ბრიტანეთი</option>
    <!-- შერჩეული ვარიანტისთვის შეგვიძლია გამოვიყენოთ "selected" -->
    <option value="usa" selected>აშშ</option> 
  </select>
</form>
\`\`\`

## ხშირად დაშვებული შეცდომები
- \`<textarea>\`-ს \`value\` ატრიბუტით შევსება, როგორც \`<input>\`-ის შემთხვევაში. \`<textarea>\`-ში ტექსტი უნდა დაიწეროს გამხსნელ და დამხურავ ტეგებს შორის: \`<textarea>ჩემი ტექსტი</textarea>\`.
- \`<select>\` ველში პირდაპირ ტექსტის ჩაწერა, ნაცვლად \`<option>\` ტეგების გამოყენებისა.

## ქვიზი
1. რითი განსხვავდება <textarea> ჩვეულებრივი <input type="text" />-ისგან?
- [x] Input იტევს მხოლოდ ერთ ხაზს, ხოლო textarea განკუთვნილია ვრცელი, მრავალხაზიანი ტექსტებისთვის.
- [ ] Textarea-დან მონაცემები სერვერზე არ იგზავნება.
- [ ] არაფრით.

2. რომელი ტეგი გამოიყენება ჩამოსაშლელი მენიუს თითოეული ვარიანტის (ნივთის) შესაქმნელად?
- [ ] <item>
- [x] <option>
- [ ] <choice>

3. თუ გვინდა, რომ ჩამოსაშლელი მენიუ ჩატვირთვისთანავე უკვე აჩვენებდეს გარკვეულ პასუხს (წინასწარ მონიშნულს), რომელ ატრიბუტს ვუწერთ შესაბამის \`<option>\`-ს?
- [ ] active
- [ ] disabled
- [x] selected
    `,
    starter_code: `<form>
  <!-- დაამატეთ აკლივ ტეგები აქ -->
  
  <select>
    
  </select>
</form>`,
    solution_code: `<form>
  <textarea></textarea>
  <select>
    <option>დიახ</option>
    <option>არა</option>
  </select>
</form>`,
    challenge_text: `ფორმის შიგნით ერთმანეთის მიყოლებით შექმენით ჯერ ერთი ცარიელი <strong>textarea</strong>, ხოლო მის ქვემოთ ჩამოსაშლელი სია (<strong>select</strong>), რომლის შიგნითაც იქნება ორი ასარჩევი <strong>option</strong> (მაგალითად: დიახ, არა).`,
    test_cases: JSON.stringify([
      { testName: 'textarea ტეგი უნდა არსებობდეს', testCode: 'expect(document.querySelector("textarea")).toBeTruthy();' },
      { testName: 'select ტეგი უნდა შეიცავდეს 2 ცალ option-ს', testCode: 'expect(document.querySelectorAll("select option").length).toBe(2);' }
    ])
  },
  {
    id: '10000000-0001-0003-0000-000000000004',
    course_id: courseId,
    title: 'button ტიპები — submit, reset, button',
    slug: 'html-button-types-submit',
    content_type: 'practice',
    language: 'html',
    xp_reward: 20,
    sort_order: 4,
    estimated_minutes: 10,
    content: `
# button ტიპები — submit, reset, button

## თეორია

ფორმის ველების შევსების შემდეგ საჭიროა მოქმედების განხორციელება — ინფორმაციის გაგზავნა ან ველების გასუფთავება. ამისთვის ვიყენებთ ღილაკებს. HTML-ში ღილაკის შესაქმნელად ყველაზე გავრცელებული ტეგია \`<button>\`.

\`<button>\` ტეგს გააჩნია ძალიან მნიშვნელოვანი ატრიბუტი \`type\`, რომელიც განსაზღვრავს მის ქცევას ფორმის შიგნით. არსებობს 3 ძირითადი ტიპი:

1. **\`type="submit"\` (გაგზავნა):** თუ ღილაკს ეს ტიპი აქვს, მასზე დაჭერით ფორმაში არსებული ყველა მონაცემი შეგროვდება და გაიგზავნება \`<form>\` ტეგის \`action\` მისამართზე. თუ \`<form>\`-ის შიგნით დაწერთ \`<button>\`-ს და \`type\`-ს არ მიუთითებთ, ბრაუზერი ავტომატურად (default) ჩათვლის, რომ ის \`submit\` ღილაკია.
2. **\`type="reset"\` (გასუფთავება):** ამ ღილაკზე დაჭერით ფორმაში არსებული ყველა \`<input>\` ან ველი წაიშლება და დაუბრუნდება საწყის მდგომარეობას. თანამედროვე საიტებზე ის იშვიათად გამოიყენება, რადგან ხშირია მომხმარებლის მიერ შემთხვევით დაჭერა და ნაწვალები ინფორმაციის დაკარგვა.
3. **\`type="button"\` (ჩვეულებრივი ღილაკი):** თუ ფორმის შიგნით გსურთ ღილაკი, რომელიც არ გააგზავნის გამოკითხვას და არც წაშლის მას, არამედ რაიმე სხვა ქმედებას (მაგალითად JavaScript-ით პოპაპის ამოგდებას) შეასრულებს, მისთვის აუცილებელია მიუთითოთ \`type="button"\`. წინააღმდეგ შემთხვევაში, ის ფორმას გააგზავნის და გვერდს დაარეფრეშებს.

ადრე ხშირად იყენებდნენ \`<input type="submit" value="გაგზავნა">\`-საც, თუმცა \`<button>\` ტეგის გამოყენება ბევრად უკეთესია, რადგან \`<button>...\</button>\`-ის შიგნით შეგიძლიათ სურათების ან აიქონების ჩასმა ტექსტთან ერთად.

## კოდის მაგალითი
\`\`\`html
<form action="/login" method="POST">
  <input type="text" placeholder="Username">
  
  <!-- აგზავნის ფორმას (default ტიპია) -->
  <button type="submit">შესვლა</button>
  
  <!-- ასუფთავებს ფორმას -->
  <button type="reset">გასუფთავება</button>
  
  <!-- უბრალო ღილაკი ჯავასკრიპტისთვის -->
  <button type="button" onclick="alert('დახმარება!')">დახმარება</button>
</form>
\`\`\`

## ხშირად დაშვებული შეცდომები
- ჯავასკრიპტის მოვლენისთვის (მაგ. დიზაინის შეცვლისთვის) განკუთვნილი ღილაკის ფორმაში მოთავსება \`type="button"\`-ის გარეშე. დაჭერისას ეს ღილაკი ავტომატურად დაარეფრეშებს გვერდს, რაც დეველოპერს ხშირად აბნევს. 

## ქვიზი
1. რას აკეთებს ღილაკი, რომელსაც ფორმის შიგნით უწერია type="submit"?
- [ ] ის ხსნის საიტის დამალულ მენიუს.
- [x] აგზავნის ფორმის მონაცემებს სერვერზე.
- [ ] ასუფთავებს ველებს.

2. თუ ფორმის შიგნით დავწერთ \`<button>\` ტეგს \`type\` ატრიბუტის გარეშე, რა მოხდება მასზე დაჭერისას?
- [x] ის იმოქმედებს როგორც submit ფორმა და გააგზავნის მონაცემებს (ან დაარეფრეშებს გვერდს).
- [ ] არაფერი არ მოხდება.
- [ ] წაშლის ფორმის მონაცემებს.

3. რომელი ღილაკი გამოიყენება ფორმის ყველა ველის საწყის მდგომარეობაში დასაბრუნებლად?
- [ ] type="clear"
- [x] type="reset"
- [ ] type="reload"
    `,
    starter_code: `<form>
  <input type="text" placeholder="სახელი">
  <!-- შექმენით გასაგზავნი ღილაკი აქ -->
  
</form>`,
    solution_code: `<form>
  <input type="text" placeholder="სახელი">
  <button type="submit">გაგზავნა</button>
</form>`,
    challenge_text: `ფორმის შიგნით, <strong>input</strong>-ის ქვემოთ, შექმენით <strong>button</strong> ტეგი <strong>type="submit"</strong> ატრიბუტით და შიგნით ჩაუწერეთ სიტყვა "გაგზავნა".`,
    test_cases: JSON.stringify([
      { testName: 'button ტეგი უნდა არსებობდეს', testCode: 'expect(document.querySelector("button")).toBeTruthy();' },
      { testName: 'button ტიპი უნდა იყოს submit', testCode: 'expect(document.querySelector("button").getAttribute("type")).toBe("submit");' }
    ])
  }
];

module.exports = lessonsPart1;
